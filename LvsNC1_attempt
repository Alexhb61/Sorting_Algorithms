#The following is an attempt at proving L = NC^1 
#Please politely refute if its wrong.
#Definitions: L is logspace on a turing machine.
# NC^1 is log depth bounded fan-in boolean circuits.
Claim 1: NC^1 \subset L
Proof: Citation in literature to be found later.
Claim 2: The product of m permutations on n elements is complete for L under NC^1 reductions
Proof: See Cook & Mckenzie
Note: we can trivially assume n is even by adding an element which does not move in the odd case
& we can assume n is >= 9 by adding at least 10 elements in the small cases.
Claim 3: A permutation on n elements can be turned into sequence of nlogn swaps on n elements in NC^1
Proof: Take the AKS sorting network(citation needed) & for each comparator record whether or not it performs a swap.
Put this record of swaps in order of execution with parallel swaps in any order as the list of nlogn swaps.
Claim 4: The permutations p = (1 2)(n+1 n+2) and q = (1 2 3...n) where the numbers continue in order. 
Can be generated by order 2 and order 3 elements in NC^1 only given n in unary.
Proof: Needed precisely for uniformity.
Needed with O(poly(n)) generators for Correctness UNFINISHED CLAIM
Claim 5: Each swap can be mapped to a sequence of generators of the simple group A_{n+2} in NC^1 reduction
Note (n+1 n+2) will be added to each swap.
Proof: 
Given swap (j k) we use 2n memory cells indexed by i from 1 to n, each will contain either an adjacent swap or an identity element.
In the first half if i \in [j, k) put swap (i, i+1) down else put down e
In the second half if n - i \in [j, k-1) put swap (n-i, n-i +1) down else put down e
Recursing again.
Given "swap" (j j+1) (n+1 n+2) , using 2n + 1 memory cells indexed by i from 1 to n, each will contain either an adjacent swap or an identity element.
In the first half, if i < j  put down p^-1 else put down e
In the center entry, put down q 
In the second half, if i < j put down p else put down e
Given p or q or e:
Use Claim 4 to replace them with generators.
Given p^-1 invert and reverse its generator list. The order 2 generator is its own inverse, and the order three generator squares to its own inverse.
These reductions turn the swap in to O(n) adjacent swaps and each of those into O(n) of the simple permutations, then O(n) generators.
So O(n^3) generators per swap. 
Claim 6: There is an injective homomorphism from A_n to SL(2,Z) in constant depth
Proof: Invert the construction of Keith Conrad which is a sujective homomorphism in the other direction.
The two generators and the identity element of A_n are mapped to the two generators and identity element of SL(2,Z)
Since this is a reinterpretation of data it takes no depth.
Claim 7: We can compute the product of n SL(2,Z) generators in NC^1
Proof: A simple divide and conquer algorithm puts it in Algebraic NC^1 (log depth addition and multiplication gates)
But there equality is a citation in the literature to be found later.
Claim 8: we can test whether a product of permutations is the identity in NC^1
Step 1: Convert permutations to generators of SL(2,Z)
Step 2: Multiply generators of SL(2,Z) to get a
Step 3: For all possible swaps s= (i j), transform s to generators of SL(2,Z) &
Check if sa = as. If all are true the product is the identity, otherwise it isn't.
Correctness Proof: if Product(p) = e then h^-1(product(p)) \in kernal of h 
then by properties of homomorphisms product(h^-1(p)) \in kernal of h.
This kernal is a normal subgroup and thus gn = ng for all g in the group.
if product(p) != e then for one of the swaps s, product(p) s != s product(p),
(proof is a only if those locations are ignored or merely swapped would equality hold)
By injectivity, product(h^-1(p)) s != s product(h^-1(p)) Therefore the algorithm holds.
Analysis claim: we do poly(n) work and two log(n) depth algorithms and a few constant depth algorithms.
Therefore L = NC^1

To Do:
make uniform
gather citations.

